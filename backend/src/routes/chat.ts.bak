import express from 'express';
import { v4 as uuidv4 } from 'uuid';
import { AuthenticatedRequest } from '../middlewares/authenticate';
import { authenticate } from '../middlewares/authenticate';
import ChatService from '../services/chatService';
import { docClient } from '../services/dynamoClient';
import { 
  PutCommand, 
  GetCommand, 
  QueryCommand, 
  UpdateCommand,
  DeleteCommand
} from '@aws-sdk/lib-dynamodb';

const router = express.Router();

// Middleware to authenticate all chat routes
router.use(authenticate);

// Get all channels for tenant
router.get('/channels', async (req: AuthenticatedRequest, res) => {
  try {
    const userId = req.user?.userId;
    
    if (!userId) {
      return res.status(401).json({ 
        success: false, 
        message: 'User not authenticated' 
      });
    }
    
    // Query DynamoDB for channels where the user is a member
    const result = await docClient.send(
      new QueryCommand({
        TableName: 'channels',
        IndexName: 'MembershipIndex',
        KeyConditionExpression: 'memberId = :userId',
        ExpressionAttributeValues: {
          ':userId': userId
        }
      })
    );
    
    const channels = result.Items || [];
    
    res.status(200).json({
      success: true,
      data: channels
    });
  } catch (error) {
    console.error('Error fetching channels:', error);
    res.status(500).json({ 
      success: false, 
      message: 'Failed to fetch channels',
      error: (error as Error).message
    });
  }
});

// Create new channel
router.post('/channels', async (req, res) => {
  try {
    const { name, type, description } = req.body;
    const userId = req.user?.userId;
    
    if (!userId) {
      return res.status(401).json({ 
        success: false, 
        message: 'User not authenticated' 
      });
    }
    
    if (!name || !type) {
      return res.status(400).json({ 
        success: false, 
        message: 'Channel name and type are required' 
      });
    }
    
    // Create channel ID
    const channelId = uuidv4();
    
    // Create channel in DynamoDB
    await docClient.send(
      new PutCommand({
        TableName: 'channels',
        Item: {
          id: channelId,
          name,
          type,
          description: description || '',
          createdBy: userId,
          createdAt: new Date().toISOString(),
          members: [userId],
          permissions: {
            canPost: [userId],
            canInvite: [userId],
            canManage: [userId]
          }
        }
      })
    );
    
    // Create channel membership
    await docClient.send(
      new PutCommand({
        TableName: 'channel_members',
        Item: {
          channelId,
          userId,
          role: 'owner',
          joinedAt: new Date().toISOString()
        }
      })
    );
    
    res.status(201).json({
      success: true,
      data: {
        id: channelId,
        name,
        type,
        description: description || '',
        createdBy: userId,
        createdAt: new Date().toISOString()
      }
    });
  } catch (error) {
    console.error('Error creating channel:', error);
    res.status(500).json({ 
      success: false, 
      message: 'Failed to create channel',
      error: (error as Error).message
    });
  }
});

// Get channel messages
router.get('/channels/:channelId/messages', async (req, res) => {
  try {
    const { channelId } = req.params;
    const userId = req.user?.userId;
    
    if (!userId) {
      return res.status(401).json({ 
        success: false, 
        message: 'User not authenticated' 
      });
    }
    
    // Get channel to check membership
    const channelResult = await docClient.send(
      new GetCommand({
        TableName: 'channels',
        Key: { id: channelId }
      })
    );
    
    const channel = channelResult.Item;
    
    if (!channel) {
      return res.status(404).json({ 
        success: false, 
        message: 'Channel not found' 
      });
    }
    
    // Check if user is a member of the channel
    if (!channel.members.includes(userId)) {
      return res.status(403).json({ 
        success: false, 
        message: 'You are not a member of this channel' 
      });
    }
    
    // Query messages
    const result = await docClient.send(
      new QueryCommand({
        TableName: 'channel_messages',
        KeyConditionExpression: 'channelId = :channelId',
        ExpressionAttributeValues: {
          ':channelId': channelId
        },
        ScanIndexForward: false, // Sort in descending order (newest first)
        Limit: 50
      })
    );
    
    const messages = result.Items || [];
    
    res.status(200).json({
      success: true,
      data: messages
    });
  } catch (error) {
    console.error('Error fetching channel messages:', error);
    res.status(500).json({ 
      success: false, 
      message: 'Failed to fetch channel messages',
      error: (error as Error).message
    });
  }
});

// Send message
router.post('/channels/:channelId/messages', async (req, res) => {
  try {
    const { channelId } = req.params;
    const { content, type = 'text', files = [], replyTo } = req.body;
    const userId = req.user?.userId;
    
    if (!userId) {
      return res.status(401).json({ 
        success: false, 
        message: 'User not authenticated' 
      });
    }
    
    // Get channel to check membership
    const channelResult = await docClient.send(
      new GetCommand({
        TableName: 'channels',
        Key: { id: channelId }
      })
    );
    
    const channel = channelResult.Item;
    
    if (!channel) {
      return res.status(404).json({ 
        success: false, 
        message: 'Channel not found' 
      });
    }
    
    // Check if user is a member of the channel
    if (!channel.members.includes(userId)) {
      return res.status(403).json({ 
        success: false, 
        message: 'You are not a member of this channel' 
      });
    }
    
    const message = await chatService.createMessage({
      channelId,
      senderId: userId,
      content,
      type,
      files,
      replyTo,
      tenantId: req.user.tenantId,
      reactions: [],
      readBy: [],
      isEdited: false,
      isDeleted: false
    });

    res.status(201).json({ data: message });
  } catch (error) {
    console.error('Error sending message:', error);
    res.status(500).json({ 
      success: false, 
      message: 'Failed to send message',
      error: (error as Error).message
    });
  }
});

// Add reaction to message
router.post('/channels/:channelId/messages/:messageTimestamp/reactions', async (req, res) => {
  try {
    const { channelId, messageTimestamp } = req.params;
    const { emoji } = req.body;
    const userId = req.user?.userId;
    
    if (!userId) {
      return res.status(401).json({ 
        success: false, 
        message: 'User not authenticated' 
      });
    }
    
    // Get message to check permissions
    const messageResult = await docClient.send(
      new GetCommand({
        TableName: 'channel_messages',
        Key: { 
          channelId,
          id: messageTimestamp
        }
      })
    );
    
    const message = messageResult.Item;
    
    if (!message) {
      return res.status(404).json({ 
        success: false, 
        message: 'Message not found' 
      });
    }
    
    // Check if user has permission to react
    if (!message.reactions.some((reaction: any) => reaction.userId === userId)) {
      return res.status(403).json({ 
        success: false, 
        message: 'You do not have permission to react to this message' 
      });
    }
    
    // Add reaction
    const updatedReactions = [...message.reactions, { userId, emoji }];
    
    await docClient.send(
      new UpdateCommand({
        TableName: 'channel_messages',
        Key: { 
          channelId,
          id: messageTimestamp
        },
        UpdateExpression: 'set reactions = :reactions',
        ExpressionAttributeValues: {
          ':reactions': updatedReactions
        }
      })
    );
    
    res.status(200).json({
      success: true,
      message: 'Reaction added successfully'
    });
  } catch (error) {
    console.error('Error adding reaction:', error);
    res.status(500).json({ 
      success: false, 
      message: 'Failed to add reaction',
      error: (error as Error).message
    });
  }
});

// Mark message as read
router.post('/channels/:channelId/messages/:messageTimestamp/read', async (req, res) => {
  try {
    const { channelId, messageTimestamp } = req.params;
    const userId = req.user?.userId;
    
    if (!userId) {
      return res.status(401).json({ 
        success: false, 
        message: 'User not authenticated' 
      });
    }
    
    // Get message
    const messageResult = await docClient.send(
      new GetCommand({
        TableName: 'channel_messages',
        Key: { 
          channelId,
          id: messageTimestamp
        }
      })
    );
    
    const message = messageResult.Item;
    
    if (!message) {
      return res.status(404).json({ 
        success: false, 
        message: 'Message not found' 
      });
    }
    
    // Add read receipt
    const readReceipt = {
      userId,
      readAt: new Date().toISOString()
    };
    
    // Check if user already read the message
    const readBy = message.readBy || [];
    const alreadyRead = readBy.some((receipt: any) => receipt.userId === userId);
    
    if (!alreadyRead) {
      await docClient.send(
        new UpdateCommand({
          TableName: 'channel_messages',
          Key: { 
            channelId,
            id: messageTimestamp
          },
          UpdateExpression: 'set readBy = list_append(if_not_exists(readBy, :emptyList), :readReceipt)',
          ExpressionAttributeValues: {
            ':emptyList': [],
            ':readReceipt': [readReceipt]
          }
        })
      );
    }
    
    res.status(200).json({
      success: true,
      message: 'Message marked as read'
    });
  } catch (error) {
    console.error('Error marking message as read:', error);
    res.status(500).json({ 
      success: false, 
      message: 'Failed to mark message as read',
      error: (error as Error).message
    });
  }
});

// Add member to channel
router.post('/channels/:channelId/members', async (req, res) => {
  try {
    const { channelId } = req.params;
    const { userId: memberToAdd, role } = req.body;
    const userId = req.user?.userId;
    
    if (!userId) {
      return res.status(401).json({ 
        success: false, 
        message: 'User not authenticated' 
      });
    }
    
    // Get channel to check permissions
    const channelResult = await docClient.send(
      new GetCommand({
        TableName: 'channels',
        Key: { id: channelId }
      })
    );
    
    const channel = channelResult.Item;
    
    if (!channel) {
      return res.status(404).json({ 
        success: false, 
        message: 'Channel not found' 
      });
    }
    
    // Check if user has permission to invite
    if (!channel.permissions.canInvite.includes(userId)) {
      return res.status(403).json({ 
        success: false, 
        message: 'You do not have permission to add members to this channel' 
      });
    }
    
    // Check if member is already in channel
    if (channel.members.includes(memberToAdd)) {
      return res.status(400).json({ 
        success: false, 
        message: 'User is already a member of this channel' 
      });
    }
    
    // Add member to channel
    await docClient.send(
      new UpdateCommand({
        TableName: 'channels',
        Key: { id: channelId },
        UpdateExpression: 'set members = list_append(members, :newMember), permissions.canPost = list_append(permissions.canPost, :newMember)',
        ExpressionAttributeValues: {
          ':newMember': [memberToAdd]
        }
      })
    );
    
    // Create channel membership
    await docClient.send(
      new PutCommand({
        TableName: 'channel_members',
        Item: {
          channelId,
          userId: memberToAdd,
          role: role || 'member',
          joinedAt: new Date().toISOString(),
          addedBy: userId
        }
      })
    );
    
    res.status(200).json({
      success: true,
      message: 'Member added to channel'
    });
  } catch (error) {
    console.error('Error adding member to channel:', error);
    res.status(500).json({ 
      success: false, 
      message: 'Failed to add member to channel',
      error: (error as Error).message
    });
  }
});

// Remove member from channel
router.delete('/channels/:channelId/members/:memberId', async (req, res) => {
  try {
    const { channelId, memberId } = req.params;
    const userId = req.user?.userId;
    
    if (!userId) {
      return res.status(401).json({ 
        success: false, 
        message: 'User not authenticated' 
      });
    }
    
    // Get channel to check permissions
    const channelResult = await docClient.send(
      new GetCommand({
        TableName: 'channels',
        Key: { id: channelId }
      })
    );
    
    const channel = channelResult.Item;
    
    if (!channel) {
      return res.status(404).json({ 
        success: false, 
        message: 'Channel not found' 
      });
    }
    
    // Check if user has permission to manage channel or is removing themselves
    if (!channel.permissions.canManage.includes(userId) && userId !== memberId) {
      return res.status(403).json({ 
        success: false, 
        message: 'You do not have permission to remove members from this channel' 
      });
    }
    
    // Check if member is in channel
    if (!channel.members.includes(memberId)) {
      return res.status(400).json({ 
        success: false, 
        message: 'User is not a member of this channel' 
      });
    }
    
    // Remove member from channel
    const updatedMembers = channel.members.filter((id: string) => id !== memberId);
    const updatedCanPost = channel.permissions.canPost.filter((id: string) => id !== memberId);
    const updatedCanInvite = channel.permissions.canInvite.filter((id: string) => id !== memberId);
    const updatedCanManage = channel.permissions.canManage.filter((id: string) => id !== memberId);
    
    await docClient.send(
      new UpdateCommand({
        TableName: 'channels',
        Key: { id: channelId },
        UpdateExpression: 'set members = :members, permissions.canPost = :canPost, permissions.canInvite = :canInvite, permissions.canManage = :canManage',
        ExpressionAttributeValues: {
          ':members': updatedMembers,
          ':canPost': updatedCanPost,
          ':canInvite': updatedCanInvite,
          ':canManage': updatedCanManage
        }
      })
    );
    
    // Delete channel membership
    await docClient.send(
      new DeleteCommand({
        TableName: 'channel_members',
        Key: {
          channelId,
          userId: memberId
        }
      })
    );
    
    res.status(200).json({
      success: true,
      message: 'Member removed from channel'
    });
  } catch (error) {
    console.error('Error removing member from channel:', error);
    res.status(500).json({ 
      success: false, 
      message: 'Failed to remove member from channel',
      error: (error as Error).message
    });
  }
});

// Get chat history (if needed in the future)
router.get('/history/:userId', async (req, res) => {
  const { userId } = req.params;
  // For now, return empty array since we're using in-memory storage
  res.json({ data: [] });
});

// Get user's active chats (if needed in the future)
router.get('/active', async (req, res) => {
  // For now, return empty array since we're using in-memory storage
  res.json({ data: [] });
});

export default router; 